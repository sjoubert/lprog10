\section{Conclusion}

Nos objectifs initiaux étaient d'identifier des caractéristiques communes aux différents langages de programmation afin de les comparer. La carte d'identité résultante de l'étude permet effectivement de réaliser cette comparaison. Les regroupements de caractéristiques ont été fait de la manière la plus cohérente possible, cependant ce n'est sûrement pas la seule façon d'organiser une telle carte d'identité. Les principales caractéristiques y sont présentes bien que l'on puisse probablement en ajouter ou les organiser différemment.\\

La principale difficulté a été de bien cerner les valeurs possibles de caractéristiques. En effet, il s'avère que la plupart d'entre elles ne peuvent pas être remplies de manière objective. Par exemple, la liste des paradigmes supportés par un langage ne peut pas être exhaustive : certains paradigmes ne sont supportés que partiellement, ou sont spécifiques au langage en question. De même, nous avons définis les notions de typages fort | faible, statique | dynamique et explicite | implicite, mais certains langages utilisent un mélange plutôt flou de ces notions. L'exemple le plus frappant de la subjectivité des valeurs de caractéristiques est la mesure de la popularité d'un langage.\\

Ainsi, si l'on voulait réellement construire une base de données pour stocker ces cartes d'identité, il faudrait faire des choix arbitraires quant aux valeurs possibles des caractéristiques. L'étude a permis de se rendre compte que la définition d'une carte d'identité objective et universelle est irréalisable. Cependant, une fois certains choix de conception effectués, il semble tout à fait possible de construire et remplir une bibliothèque des langages de programmation. Une telle base de données permettrait à un programmeur de choisir parmi un panel de langages disponibles celui qui correspond le mieux à ses attentes.\\

Une suite intéressante à ce projet pourrait être l'étude d'une carte similaire en ce qui concerne les autres types de langages : langages de structuration de données, langages de requêtes, …. Et pourquoi pas les langages naturels ?